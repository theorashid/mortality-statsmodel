# Theo AO Rashid -- March 2020

# ----- Hierarchical model -----
# Common terms (normal prior) +
# Random effects for each LAD (normal prior) +
# Random effects for each MSOA (normal prior, hierarchy) +
# Random effects for each LSOA (normal prior, hierarchy) +
# Age effects (random walk prior) +
# age-space interactions (normal prior) +
# age-space-time overdispersion (normal prior)
#
# ONS hierarchy LSOA -> MSOA -> LAD
# --------------------

library(RCurl)
library(dplyr)
library(nimble)
library(igraph)

set.seed(1)

# ----- IMPORT DATA -----
# url <- getURL("https://media.githubusercontent.com/media/theorashid/mortality-statsmodel/master/Data/mortsim.csv") # London
url <- getURL("https://raw.githubusercontent.com/theorashid/mortality-statsmodel/master/Data/mortsim_hf.csv") # Hammersmith and Fulham
mortality <- read.csv(text = url) %>%
  select(-X) # remove autogenerated column

mortality_m <- mortality %>% # Select male sex
  filter(sex == 1) %>%
  select(-sex)

grid.lookup <- mortality_m %>% # lookup correct MSOA or LAD for that LSOA
  select(LSOA.id, MSOA.id, LAD.id) %>%
  distinct() %>%
  arrange(LSOA.id) # arrange ascending so matches loop order
grid.lookup <- as.matrix(grid.lookup) # grid.lookup[j, 2] for MSOA, grid.lookup[j, 3] for LAD

grid.lookup.MSOA <- mortality_m %>% # lookup correct LAD for that MSOA
  select(MSOA.id, LAD.id) %>%
  distinct() %>%
  arrange(MSOA.id) # arrange ascending so matches loop order
grid.lookup.MSOA <- as.matrix(grid.lookup.MSOA) # grid.lookup[j, 2] for LAD

# Dimensions (Hammersmith and Fulham unit test second value):
# - age -- 19 (0, 1-4, 5-10, ..., 80-84, 85+)
# - LAD -- 33 or 1
# - MSOA -- 983 or 25
# - LSOA -- 4835 or 113
# - YEAR -- 14 (2004-17)

# ----- BUILD THE MODEL -----
# Indices:
# - a -- age
# - j -- space, each LSOA
# - t -- year (time)
code <- nimbleCode({
    # PRIORS

    # COMMON TERMS
	alpha0 ~ dnorm(0, 0.00001)
	beta0  ~ dnorm(0, 0.00001)
    
    # AREA TERMS -- random effects for intercepts and slopes
	# Lower level term centred on higher level
    
    # LAD terms
    for(j_LAD in 1:N_LAD){
        alpha_LAD[j_LAD] ~ dnorm(alpha0, tau_alpha_LAD) # centred on common terms
        beta_LAD[j_LAD] ~ dnorm(beta0, tau_beta_LAD)
    }
    sigma_alpha_LAD ~ dunif(0,2)
	tau_alpha_LAD <- pow(sigma_alpha_LAD,-2)
	sigma_beta_LAD  ~ dunif(0,2)
	tau_beta_LAD  <- pow(sigma_beta_LAD,-2)

    # MSOA terms
    for(j_MSOA in 1:N_MSOA){
        alpha_MSOA[j_MSOA] ~ dnorm(alpha_LAD[grid.lookup.MSOA[j_MSOA, 2]], tau_alpha_MSOA) # centred on LAD terms
        beta_MSOA[j_MSOA] ~ dnorm(beta_LAD[grid.lookup.MSOA[j_MSOA, 2]], tau_beta_MSOA)
    }
    sigma_alpha_MSOA ~ dunif(0,2)
	tau_alpha_MSOA <- pow(sigma_alpha_MSOA,-2)
	sigma_beta_MSOA  ~ dunif(0,2)
	tau_beta_MSOA  <- pow(sigma_beta_MSOA,-2)

    # LSOA terms
	for(j in 1:N_LSOA){ # j_LSOA = j
        alpha_LSOA[j] ~ dnorm(alpha_MSOA[grid.lookup[j, 2]], tau_alpha_LSOA) # centred on MSOA terms
		beta_LSOA[j]  ~ dnorm(beta_MSOA[grid.lookup[j, 2]], tau_beta_LSOA)
	}
	sigma_alpha_LSOA ~ dunif(0,2)
	tau_alpha_LSOA <- pow(sigma_alpha_LSOA,-2)
	sigma_beta_LSOA  ~ dunif(0,2)
	tau_beta_LSOA  <- pow(sigma_beta_LSOA,-2)

    # AGE TERMS
	alpha_age[1] <- 0 # initialise first terms for RW
	beta_age[1]  <- 0
	for(a in 2:N_age_groups){
		alpha_age[a] ~ dnorm(alpha_age[a-1], tau_alpha_age) # RW based on previous age group
		beta_age[a]  ~ dnorm(beta_age[a-1], tau_beta_age)
	}
	sigma_alpha_age ~ dunif(0,2)
	tau_alpha_age <- pow(sigma_alpha_age,-2)
	sigma_beta_age ~ dunif(0,2)
	tau_beta_age <- pow(sigma_beta_age,-2)

    # INTERACTIONS
    # age-LSOA interactions
    for(a in 1:N_age_groups){
        for(j in 1:N_LSOA){
            xi[a, j] ~ dnorm(alpha_age[a] + alpha_LSOA[j], tau_xi) # centred on age + LSOA term
        }
    }
    sigma_xi ~ dunif(0,2)
    tau_xi <- pow(sigma_xi,-2)

    # Put all parameters together into indexed lograte with age-LSOA-time overdispersion term
	for(a in 1:N_age_groups){
        for(j in 1:N_LSOA){
            epsilon[a, j, 1] <- xi[a, j]
            for(t in 2:N_year){
                # centre t for improved sampling performance
		        lograte[a, j, t] <- xi[a, j] + (beta_LSOA[j] + beta_age[a]) * (t - 8) # xi covers age and space effects
                epsilon[a, j, t] ~ dnorm(lograte[a, j, t], tau_epsilon) # overdispersion centred on lograte
            }
        }
    }
    sigma_epsilon ~ dunif(0,2)
    tau_epsilon <- pow(sigma_epsilon,-2)

    # LIKELIHOOD
    # N total number of cells, i.e. ages*years*areas(*sex)
    for (i in 1:N) {
        # y is number of deaths in that cell, assumed Poisson 
		# mu is predicted number of deaths in that cell
        y[i] ~ dpois(mu[i])
        log(mu[i]) <- log(n[i]) + epsilon[age[i], LSOA[i], yr[i]]
    }
})

constants <- list(N = nrow(mortality_m),
                  N_year = n_distinct(mortality_m$YEAR),
                  N_LSOA = n_distinct(mortality_m$LSOA2011),
                  N_MSOA = n_distinct(mortality_m$MSOA2011),
                  N_LAD = n_distinct(mortality_m$LAD2011),
                  N_age_groups = n_distinct(mortality_m$age_group),
                  grid.lookup = grid.lookup,
                  grid.lookup.MSOA = grid.lookup.MSOA)
data <- list(y = mortality_m$deaths,
             n = mortality_m$population, 
             age = mortality_m$age_group.id,
             LSOA = mortality_m$LSOA.id, 
             yr = mortality_m$YEAR.id)

# ----- CREATE THE MODEL -----
model <- nimbleModel(code = code, constants = constants, data = data) # model in R
# model$getNodeNames() # look at nodes of model's DAG
# model$plotGraph() # plot the DAG

# ----- COMPILE THE MODEL IN C-CODE -----
Cmodel <- compileNimble(model)

# ----- MCMC INTEGRATION -----
# Initial values for uninformative priors (top-level nodes)
# Other values will be set from the model and subsequent
# chains will begin using starting values where the 
# previous chain ended
inits <- function() list(alpha0 = rnorm(1,-5,1), beta0 = rnorm(1,-0.1,0.01),
                         sigma_alpha_LSOA = runif(1, 0.01, 0.8), sigma_beta_LSOA = runif(1, 0.01, 0.8),
                         sigma_alpha_MSOA = runif(1, 0.01, 0.8), sigma_beta_MSOA = runif(1, 0.01, 0.8),
                         sigma_alpha_LAD = runif(1, 0.01, 0.8), sigma_beta_LAD = runif(1, 0.01, 0.8),
                         sigma_alpha_age = runif(1, 0.01, 0.8), sigma_beta_age = runif(1, 0.01, 0.8),
                         sigma_xi = runif(1, 0.01, 0.8), sigma_epsilon = runif(1, 0.01, 0.8))
# Monitors
# NIMBLE default only monitors top-level nodes
# Need to monitor all nodes which make up lograte with no thinning
monitors <- c("mu")
# Other monitors to check covergence, with some thinning
monitors2 <- c("alpha0", "beta0",
               "sigma_alpha_LSOA", "sigma_beta_LSOA",
               "sigma_alpha_MSOA", "sigma_beta_MSOA",
               "sigma_alpha_LAD", "sigma_beta_LAD",
               "sigma_alpha_age", "sigma_beta_age",
               "sigma_xi", "sigma_epsilon")

# CUSTOMISABLE MCMC -- configureMCMC, buildMCMC, compileNimble, runMCMC
# 1. MCMC Configuration -- can be customised with different samplers
mcmcConf <- configureMCMC(model = model,
                          monitors = monitors, monitors2 = monitors2,
                          thin = 1, thin2 = 50, print = TRUE) # input the R model

# 2. Build and compile the MCMC
Rmcmc <- buildMCMC(mcmcConf) # Set enableWAIC = TRUE if we need to calculate WAIC
Cmcmc <- compileNimble(Rmcmc)

# 3. Run MCMC
mcmc.out <- runMCMC(Cmcmc, inits = inits,
                    niter = 10000, nchains = 2, nburnin = 1000,
                    progressBar = TRUE, samples = TRUE, summary = TRUE)

# ----- SAVE OUTPUT SAMPLES AND SUMMARY -----
saveRDS(mcmc.out, file = "mcmc_out.rds")