# Theo AO Rashid -- August 2020

# ----- gam model -----
# Poisson/negative binomial likelihood
# --------------------

library(dplyr)
library(mgcv)
library(parallel)

# indicate number of cores used for parallel processing
if (detectCores() > 1) {
  this_cluster <- makeCluster(detectCores() - 20)
} else this_cluster <- NULL

print(this_cluster)

data_path    <- "/rds/general/user/tar15/home/mortality-statsmodel/Data/"
output_path <-  "/rds/general/user/tar15/home/mortality-statsmodel/Output/"

source(paste0(output_path, "period_life_table.R"))

hammersmith <- FALSE
if (hammersmith) {
  mortality <- read.csv(file = paste0(data_path, "mortsim_hf", ".csv"))
  print("LOADED HAMMERSMITH DATA")
} else {
  mortality <- read.csv(file = paste0(data_path, "mortsim", ".csv"))
  print("LOADED LONDON DATA")
}

mortality <- mortality %>%
  select(-X) %>% # remove autogenerated column
  filter(sex == 1) %>%
  select(-sex)

# get age bin "centres" from ax in life expectancy
mr <- mortality %>%
  group_by(age_group.id) %>%
  summarise(mr = sum(deaths)/sum(population))

le <- PeriodLifeTable(
  mx = mr$mr,
  age = c(c(0,1), seq(5, 85, 5)),
  ax = rep(NA,19), 
  sex = 1, full.table = TRUE)
le$age_centre <- le$ax + le$age
le$age_group.id <- 1:19

# get centroids of LSOAs
# Shape data
shapefile <- readOGR(dsn = paste0(data_path, "shapefiles/ldn_LSOA11"),
                     layer = "LSOA11_London")

# Merge with mortality
colnames(shapefile@data)[1] <- "LSOA2011"
shapefile <- merge(shapefile, distinct(select(mortality, LSOA2011, LSOA.id, LAD.id)))
shapefile <- shapefile[!is.na(shapefile$LSOA.id) ,] # remove NA rows for subsetting (Hammersmith and Fulahm)
shapefile <- shapefile[order(shapefile$LSOA.id),] # reorder on LSOA.id
row.names(shapefile@data) <- shapefile@data$LSOA.id

# get centroids
locs <- SpatialPointsDataFrame(shapefile, shapefile@data)
class(locs@coords)

locs_mat <- data.frame(locs@coords)
locs_mat$LSOA2011 <- locs@data$LSOA2011

mortality <- left_join(mortality, locs_mat, by = "LSOA2011")
mortality <- left_join(mortality, le[, c("age_group.id", "age_centre")], by = "age_group.id")

# need to filter mortality with population > 0
# tensor product of separate thin plate terms
# offset outside so it does not act in predict
# optimise k so EDF does not change too much
# MODEL TAKES x10 longer than discrete = TRUE for similar output
# system.time(
#   mod <- bam(formula = deaths ~ te(coords.x1, coords.x2, YEAR.id, age_centre,
#                                    bs = c("tp", "tp", "tp"), k = c(30, 10, 10), 
#                                    d = c(2, 1, 1)), 
#              data = filter(mortality, population > 0), family = nb(),
#              offset = log(population), cluster = this_cluster)
# )

system.time(
  mod <- bam(formula = deaths ~ te(coords.x1, coords.x2, YEAR.id, age_centre,
                                   bs = c("tp", "tp", "tp"), k = c(100, 10, 12), 
                                   d = c(2, 1, 1)), 
             data = filter(mortality, population > 0), family = nb(),
             offset = log(population), discrete = TRUE, nthreads = 8) # set nthreads to cluster size
)
# bam not optimised for thin plate
# could use discrete = TRUE
summary(mod)
print(mod)
print(mod$family)
gam.check(mod) # low p values -- residuals not randomly distributed, need a larger K
# concurvity(mod) # low -> less similarity to other variables
AIC(mod)
plot(mod, scheme = 1, pages = 1, rug = TRUE, residuals = TRUE,
     shade = TRUE, shade.col = "lightsteelblue")
vis.gam(x = mod, view = c("coords.x1", "coords.x2"), plot.type = "persp", se = 1, theta = 60)

# help(predict.gam) # get response on the right scale
# The standard errors produced by predict.gam are based on the
# Bayesian posterior covariance matrix of the parameters Vp in the fitted gam object.
predict(mod, newdata = mortality, type = "response", cluster = this_cluster)

# getting drawsfrom the quasi-posterior to calculate CI
num_draws <- 3 # 1000
Xp <- predict(mod, newdata = mortality, type = "lpmatrix", cluster = this_cluster) # memory intensive
Xp <- predict(mod, newdata = filter(mortality, MSOA.id == 1), type = "lpmatrix", cluster = this_cluster)
rmvnd <- function(n, mu, sig) { ## MVN random deviates
  L <- mroot(sig)
  m <- ncol(L)
  t(mu + L %*% matrix(rnorm(m*n), m, n)) 
}
draws_coef <- rmvnd(num_draws, coef(mod), mod$Vp) 
draws_linpred <- Xp %*% t(draws_coef)
draws_mr <- exp(draws_linpred) # response scale for log link

stopCluster(this_cluster)
