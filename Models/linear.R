# Theo AO Rashid -- March 2020

# ----- Linear model -----
# Simple model with only "common" terms
# --------------------

library(RCurl)
library(dplyr)
library(nimble)
library(igraph)

set.seed(1)

# ----- IMPORT DATA -----
# url <- getURL("https://media.githubusercontent.com/media/theorashid/mortality-statsmodel/master/Data/mortsim.csv") # London
url <- getURL("https://media.githubusercontent.com/media/theorashid/mortality-statsmodel/master/Data/mortsim_hf.csv") # Hammersmith and Fulham
mortality <- read.csv(text = url) %>%
  select(-X) # remove autogenerated column

mortality_m <- mortality %>% # Select male sex
  filter(sex == 1) %>%
  select(-sex)

# Dimensions (Hammersmith and Fulham unit test second value):
# - age -- 19 (0, 1-4, 5-10, ..., 80-84, 85+)
# - LAD -- 33 or 1
# - MSOA -- 983 or 25
# - LSOA -- 4835 or 113
# - YEAR -- 14 (2004-17)

# ----- BUILD THE MODEL -----
# Indices:
# - a -- age
# - j -- space, each LSOA
# - t -- year (time)
code <- nimbleCode({
  # PRIORS
	#dnorm is mean, precision
	alpha0 ~ dnorm(0, 0.00001)
	beta0  ~ dnorm(0, 0.00001)

  # Put all parameters together into indexed lograte
	for(a in 1:N_age_groups){
	  for(j in 1:N_LSOA){
	    for(t in 1:N_year){
	      # remember to centre your t to improve sampling performance
        # (cuts down correlation between parameters)
        # DO NOT make it a dynamic centrering
				lograte[a, j, t] <- alpha0 + beta0 * (t - 8)
      }
    }
  }

  # LIKELIHOOD
  # N total number of cells, i.e. ages*years*areas(*sex)
  for (i in 1:N) {
    # y is number of deaths in that cell, assumed Poisson 
		# mu is predicted number of deaths in that cell
    y[i] ~ dpois(mu[i])
    log(mu[i]) <- log(n[i]) + lograte[age[i], LSOA[i], yr[i]]
  }
})

# need initial estimates for alpha0, beta0
constants <- list(N = nrow(mortality_m),
                  N_year = n_distinct(mortality_m$YEAR),
                  N_LSOA = n_distinct(mortality_m$LSOA2011),
                  N_age_groups = n_distinct(mortality_m$age_group))
data <- list(y = mortality_m$deaths,
             n = mortality_m$population, 
             age = mortality_m$age_group.id,
             LSOA = mortality_m$LSOA.id, 
             yr = mortality_m$YEAR.id)

# ----- CREATE THE MODEL -----
model <- nimbleModel(code = code, constants = constants, data = data) # model in R
# model$getNodeNames() # look at nodes of model's DAG
# model$plotGraph() # plot the DAG

# ----- COMPILE THE MODEL IN C-CODE -----
Cmodel <- compileNimble(model)

# ----- MCMC INTEGRATION -----
inits <- function() list(alpha0 = rnorm(1,0,1), beta0 = rnorm(1,0,1))
# ONE LINE MCMC
mcmc.out <- nimbleMCMC(model = Cmodel, inits = inits,
                       thin = 1, niter = 10000, nchains = 2, nburnin = 1000,
                       progressBar = TRUE, samples = TRUE, summary = TRUE)

# # CUSTOMISABLE MCMC -- configureMCMC, buildMCMC, compileNimble, runMCMC
# # 1. MCMC Configuration -- can be customised with different samplers
# mcmcConf <- configureMCMC(model = model, print = TRUE) # input the R model

# # 2. Build and compile the MCMC
# Rmcmc <- buildMCMC(mcmcConf) # Set enableWAIC = TRUE if we need to calculate WAIC
# Cmcmc <- compileNimble(Rmcmc)

# # 3. Run MCMC
# mcmc.out <- runMCMC(Cmcmc, inits = inits,
#                     thin = 1, niter = 10000, nchains = 2, nburnin = 1000,
#                     progressBar = TRUE, samples = TRUE, summary = TRUE) # similar to nimbleMCMC

# POSSIBLE TO RUN MCMC CHAINS IN PARALLEL BUT REQUIRES
# CREATING A MODEL AGAIN

# ----- SAVE OUTPUT SAMPLES AND SUMMARY -----
saveRDS(mcmc.out, file = "mcmc_out.rds")
