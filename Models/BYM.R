# Theo AO Rashid -- April 2020

# ----- BYM model -----
# Common terms (normal prior) +
# BYM for each LSOA +
# Age effects (random walk prior) +
# Age-LSOA interaction (normal prior) +
# Age-time interaction (random walk prior) +
# LSOA-time interaction (random walk prior) +
# Overdispersion term (normal prior)
# --------------------

library(rgdal)
library(spdep)
library(RCurl)
library(dplyr)
library(nimble)
library(igraph)

set.seed(1)

# ----- IMPORT DATA -----
# Mortality data
# url <- getURL("https://media.githubusercontent.com/media/theorashid/mortality-statsmodel/master/Data/mortsim.csv") # London
url <- getURL("https://raw.githubusercontent.com/theorashid/mortality-statsmodel/master/Data/mortsim_hf.csv") # Hammersmith and Fulham
mortality <- read.csv(text = url) %>%
  select(-X) # remove autogenerated column

mortality_m <- mortality %>% # Select male sex
  filter(sex == 1) %>%
  select(-sex)

# Shape data
shapefile <- readOGR(dsn = "Data/shapefiles/ldn_LSOA11",
                layer = "LSOA11_London")

# Merge with mortality
colnames(shapefile@data)[1] <- "LSOA2011"
shapefile <- merge(shapefile, distinct(select(mortality_m, LSOA2011, LSOA.id, LAD.id)))
shapefile <- shapefile[!is.na(shapefile$LSOA.id) ,] # remove NA rows for subsetting (Hammersmith and Fulahm)
shapefile <- shapefile[order(shapefile$LSOA.id),] # reorder on LSOA.id
row.names(shapefile@data) <- shapefile@data$LSOA.id

# Extract adjacency matrix
W.nb <- poly2nb(shapefile, row.names = rownames(shapefile@data))
nbInfo <- nb2WB(W.nb)
# adj = nbInfo$adj, weights = nbInfo$weights, num = nbInfo$num

# Dimensions (Hammersmith and Fulham unit test second value):
# - age -- 19 (0, 1-4, 5-10, ..., 80-84, 85+)
# - LAD -- 33 or 1
# - MSOA -- 983 or 25
# - LSOA -- 4835 or 113
# - YEAR -- 14 (2004-17)

# ----- BUILD THE MODEL -----
# Indices:
# - a -- age
# - j -- space, each LSOA
# - t -- year (time)
code <- nimbleCode({
  # PRIORS

  # COMMON TERMS
	alpha0 ~ dnorm(0, 0.00001)
	beta0  ~ dnorm(0, 0.00001)
    
  # AREA TERMS -- BYM prior for LSOAs (not BYM2 as do not need to interpret)
  # No hierarchy
  # Structured intercept and slope with a CAR prior
  alpha_u[1:N_LSOA] ~ dcar_normal(adj[1:L], weights[1:L], num[1:N_LSOA], tau_alpha_u, zero_mean = 0)
  beta_u[1:N_LSOA]  ~ dcar_normal(adj[1:L], weights[1:L], num[1:N_LSOA], tau_beta_u, zero_mean = 0)
	# Unstructured IID intercept and slope
  for(j in 1:N_LSOA){
    alpha_v[j] ~ dnorm(alpha0 + alpha_u[j], tau_alpha_v) # centred on common + CAR term
    beta_v[j]  ~ dnorm(beta0 + beta_u[j], tau_beta_v)
	}
  sigma_alpha_u ~ dunif(0,2)
	tau_alpha_u <- pow(sigma_alpha_u,-2)
  sigma_beta_u ~ dunif(0,2)
	tau_beta_u <- pow(sigma_beta_u,-2)
	sigma_alpha_v ~ dunif(0,2)
	tau_alpha_v <- pow(sigma_alpha_v,-2)
	sigma_beta_v ~ dunif(0,2)
	tau_beta_v <- pow(sigma_beta_v,-2)

  # AGE TERMS
	alpha_age[1] <- 0 # initialise first terms for RW
	beta_age[1]  <- 0
	for(a in 2:N_age_groups){
    alpha_age[a] ~ dnorm(alpha_age[a-1], tau_alpha_age) # RW based on previous age group
		beta_age[a]  ~ dnorm(beta_age[a-1], tau_beta_age)
	}
	sigma_alpha_age ~ dunif(0,2)
	tau_alpha_age <- pow(sigma_alpha_age,-2)
	sigma_beta_age ~ dunif(0,2)
	tau_beta_age <- pow(sigma_beta_age,-2)

  # INTERACTIONS
	# age-LSOA interactions
	for(a in 1:N_age_groups){
	  for(j in 1:N_LSOA){
	    xi[a, j] ~ dnorm(alpha_age[a] + alpha_v[j], tau_xi) # centred on age + LSOA term
	  }
	}
	sigma_xi ~ dunif(0,2)
	tau_xi <- pow(sigma_xi,-2)
	
	# LSOA-time interactions
	for(j in 1:N_LSOA){
	  nu[j, 1] <- 0
	  for(t in 2:N_year){
	    # the difference between timesteps is beta_v * time (where timestep length is 1 year)
	    nu[j, t] ~ dnorm(nu[j, t-1] + beta_v[j], tau_nu) # beta_v incorporates beta term
	  }
	}
	sigma_nu ~ dunif(0,2)
	tau_nu <- pow(sigma_nu,-2)
	
	# age-time interactions
	for(a in 1:N_age_groups){
	  gamma[a, 1] <- 0
	  for(t in 2:N_year){
	    # the difference between timesteps is beta_age * time (where timestep length is 1 year)
	    gamma[a, t] ~ dnorm(gamma[a, t-1] + beta_age[a], tau_gamma)
	  }
	}
	sigma_gamma ~ dunif(0,2)
	tau_gamma <- pow(sigma_gamma,-2)
	
  # Put all parameters together into indexed lograte with age-LSOA-time overdispersion term
	for(a in 1:N_age_groups){
    for(j in 1:N_LSOA){
      epsilon[a, j, 1] <- xi[a, j]
      for(t in 2:N_year){
		    lograte[a, j, t] <- xi[a, j] + nu[j, t] + gamma[a, t]
		    epsilon[a, j, t] ~ dnorm(lograte[a, j, t], tau_epsilon)
      }
    }
	}
	sigma_epsilon ~ dunif(0,2)
	tau_epsilon <- pow(sigma_epsilon,-2)

  # LIKELIHOOD
  # N total number of cells, i.e. ages*years*areas(*sex)
  for (i in 1:N) {
    # y is number of deaths in that cell, assumed Poisson 
		# mu is predicted number of deaths in that cell
    y[i] ~ dpois(mu[i])
    log(mu[i]) <- log(n[i]) + epsilon[age[i], LSOA[i], yr[i]]
  }
})

constants <- list(N = nrow(mortality_m),
                  N_year = n_distinct(mortality_m$YEAR),
                  N_LSOA = n_distinct(mortality_m$LSOA2011),
                  N_age_groups = n_distinct(mortality_m$age_group),
                  L = length(nbInfo$adj), 
                  adj = nbInfo$adj,
                  weights = nbInfo$weights,
                  num = nbInfo$num,
                  age = mortality_m$age_group.id,
                  LSOA = mortality_m$LSOA.id,
                  yr = mortality_m$YEAR.id)
data <- list(y = mortality_m$deaths,
             n = mortality_m$population)

# Initial values for uninformative priors (top-level nodes)
# mu, lograte, alpha_age, beta_age not initialised
inits <- list(alpha0 = -5.5, beta0 = 0.2,
              alpha_u = sample(c(-0.1, 0.1), constants$N_LSOA, replace = TRUE),
              beta_u = sample(c(-0.1, 0.1), constants$N_LSOA, replace = TRUE),
              sigma_alpha_u = 0.1, sigma_beta_u = 0.1,
              alpha_v = sample(c(-0.1, 0.1), constants$N_LSOA, replace = TRUE),
              beta_v = sample(c(-0.1, 0.1), constants$N_LSOA, replace = TRUE),
              sigma_alpha_v = 0.1, sigma_beta_v = 0.1,
              sigma_alpha_age = 0.75, sigma_beta_age = 0.015,
              sigma_xi = 0.08, sigma_nu = 0.1,
              sigma_gamma = 0.1, sigma_epsilon = 0.1)

# ----- CREATE THE MODEL -----
model <- nimbleModel(code = code, constants = constants, inits = inits, data = data) # model in R
# model$getNodeNames() # look at nodes of model's DAG
# model$plotGraph() # plot the DAG

# ----- COMPILE THE MODEL IN C-CODE -----
Cmodel <- compileNimble(model)

# ----- MCMC INTEGRATION -----
# Monitors
# NIMBLE default only monitors top-level nodes
# Monitor death rate per person with no thinning
monitors <- c("epsilon")
# Other monitors to check covergence, with some thinning
monitors2 <- c("alpha0", "beta0",
               "sigma_alpha_u", "sigma_beta_u",
               "sigma_alpha_v", "sigma_beta_v",
               "sigma_alpha_age", "sigma_beta_age",
               "sigma_xi", "sigma_nu",
               "sigma_gamma", "sigma_epsilon")

# CUSTOMISABLE MCMC -- configureMCMC, buildMCMC, compileNimble, runMCMC
# 1. MCMC Configuration -- can be customised with different samplers
mcmcConf <- configureMCMC(model = Cmodel,
                          monitors = monitors, monitors2 = monitors2,
                          thin = 5, thin2 = 250, print = TRUE) # input the R model

# 2. Build and compile the MCMC
Rmcmc <- buildMCMC(mcmcConf) # Set enableWAIC = TRUE if we need to calculate WAIC
Cmcmc <- compileNimble(Rmcmc)

# 3. Run MCMC
mcmc.out <- runMCMC(Cmcmc, inits = inits,
                    niter = 50000, nchains = 2, nburnin = 1000,
                    progressBar = TRUE, samples = TRUE, summary = TRUE)

# ----- SAVE OUTPUT SAMPLES AND SUMMARY -----
saveRDS(mcmc.out, file = "mcmc_out.rds")
